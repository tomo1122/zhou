### **1. 概述 (Overview)**

本文档旨在阐述系统架构设计，这是一个为响应密集型实时应用（如游戏自动化）设计的高性能框架。框架的核心目标是在处理高速视频流时，实现从数据感知到指令控制的端到端超低延迟。

### **2. 核心需求与设计原则 (Core Requirements & Design Principles)**

系统设计遵循以下核心原则：

*   **实时性 (Real-time Performance)**: 框架必须能稳定处理 **144 FPS** 甚至更高帧率的视频流，并确保关键事件的响应延迟在毫秒级。
*   **数据新鲜度优先 (Data Freshness First)**: 在所有处理环节，系统永远优先处理**最新**的数据。过时的数据（例如，上一帧的图像或状态）将被主动丢弃，以确保所有决策都基于目标应用的当前瞬时状态。
*   **广播通信 (Broadcast Communication)**: 关键数据（如视频帧、状态信息）需以广播形式分发给多个独立的下游处理模块，允许并行分析和控制。
*   **精确事件触发 (Precise Event Triggering)**: 控制指令的执行必须与特定的数据状态（如视频流的某一帧）严格同步，杜绝时序漂移。
*   **模块化与领域驱动 (Modularity & Domain-Driven Design)**: 系统被划分为独立的、按功能领域组织的模块（感知、分析、控制），以实现高内聚、低耦合，增强代码的可维护性和可扩展性。
*   **配置与代码分离 (Configuration over Code)**: 系统的所有环境依赖和可变参数均通过外部配置文件管理，实现代码的通用性和环境的快速迁移。

### **3. 系统架构 (System Architecture)**

本框架采用基于**多进程**的微服务式架构。每个核心功能模块作为一个独立的操作系统进程运行，通过专门优化的**进程间通信（IPC）机制**进行协作。

#### **3.1. 进程角色定义 (Process Roles)**

系统由以下几类核心进程构成：

| 进程名称 |  所属领域 | 核心职责 | 输入数据 | 输出数据 |
| :--- | :--- | :--- | :--- | :--- |
| **`Capture`** |  感知 (Perception) | 从数据源（如模拟器）高速捕获视频帧。 | (无) | **图像流** (`TripleSharedBuffer`) |
| **`Ruler`** |  分析 (Analysis) | 分析图像流，提取核心的时间基准——**逻辑帧**。 | 图像流 | **帧数据流** (`DoubleSharedBuffer`) |
| **`Commander`** | 控制 (Control) | 订阅**帧数据流**，根据预设脚本，在精确的逻辑帧执行核心操作。 | 帧数据流 | 控制指令 |
| **`StateMonitor`**|  分析 (Analysis) | 分析图像流，识别应用的高级状态（如：成功、失败）。 | 图像流 | **状态流** (`DoubleSharedBuffer`) |
| **`LifecycleManager`**|  控制 (Control) | 订阅**状态流**，管理应用的宏观生命周期（如：失败后重试）。 | 状态流 | 控制指令 |
| **`UI Renderer`**| 控制 (Control) | 订阅所有数据流，为用户提供一个实时的可视化监控界面。 | 所有数据流 | UI界面更新 |

#### **3.2. 进程间通信 (Inter-Process Communication)**

为实现极致性能，框架针对不同数据特性设计了专门的零拷贝或低开销IPC机制。

*   **图像流 (大数据量、高频率)**
    *   **技术选型**: **三缓冲共享内存 (`TripleSharedBuffer`)**
    *   **机制详解**:
        1.  **共享内存块**: 系统预先分配三块与单帧图像大小一致的 `SharedMemory` 区域，以及一小块额外的 `SharedMemory` 用于存储一个整数——即“最新帧”的索引。
        2.  **生产者 (`Capture`)**: 循环地将最新捕获的图像写入其中一个缓冲区。写入操作无需加锁。
        3.  **消费者 (`Ruler`)**: 通过读取那块独立的共享内存，来原子地获取“最新帧”的索引值，然后直接从对应的图像缓冲区内存地址读取数据。
    *   **实现模式：创建者/附加者 (Creator/Attacher Pattern)**
        *   **创建者**：由主进程（`run.py`）首次实例化IPC对象，负责实际创建共享内存块。
        *   **附加者**：所有子进程在启动后，都根据名称独立地实例化自己的IPC对象，并附加到已创建好的共享内存上。
    *   **优势**:
        *   **零拷贝**: 数据在进程间传递无需任何内存复制。
        *   **无锁读取**: 读写操作完全解耦，消费者不会被生产者的写入操作阻塞，反之亦然。
        *   **保证数据新鲜度**: 消费者总能获取到最新的一帧完整图像。

*   **帧数据流 / 状态流 (小数据量、高频状态)**
    *   **技术选型**: **双缓冲共享内存 (`DoubleSharedBuffer`)**
    *   **机制详解**: 这是一种高效的**拉（Pull）模型**，旨在以最低延迟共享一个小型、固定的数据结构（如 `FrameData`）。
        1.  **共享内存块**: 系统分配两个用于存储核心数据结构（如 `FrameData`）的 `SharedMemory` 槽，以及一个用于存储“最新槽”索引的 `SharedMemory` 区域。
        2.  **生产者 (`Ruler`)**: 当有新数据时，生产者将其完整写入当前**不活跃**的那个槽。写入完成后，它会**原子性地**更新共享的“最新槽”索引，使其指向刚刚写入完毕的槽。
        3.  **消费者 (`Commander`)**: 在其自身的处理循环中，消费者可以随时、无锁地读取“最新槽”索引，然后从对应的槽中安全地拷贝一份数据副本进行处理。
    *   **优势**:
        *   **极致的数据新鲜度**: 消费者总能获取到**绝对最新**的状态。如果消费者处理速度慢，它会自动跳过所有中间的过时状态，直接处理当前最新状态，完美契合“数据新鲜度优先”原则。
        *   **无锁且原子更新**: 读写操作分离，数据更新通过索引切换实现，保证消费者永远不会读到不完整（“撕裂”）的数据。
        *   **完全解耦**: 生产者只管发布最新状态，不关心是否有、有多少消费者，以及它们的处理速度。

### **4. 关键实现细节 (Key Implementation Details)**

#### **4.1. 项目结构**

项目代码按功能领域组织，结构清晰，便于维护和扩展。

```
.
├── app/
│   ├── analysis/
│   │   ├── calibrator.py             # 校准算法的核心实现
│   │   ├── cost_bar_analyzer.py      # 费用条分析逻辑
│   │   ├── ruler_process.py          # 启动Ruler进程的逻辑
│   │   └── vision_utils.py           # 视觉处理工具函数
│   ├── control/
│   │   ├── base.py                   # 控制器抽象基类
│   │   └── maatouch_adapter.py       # 使用MaaTouch的控制器实现
│   ├── core/
│   │   ├── config.py                 # 配置加载与校验 (Pydantic)
│   │   └── ipc/                      # IPC模块封装
│   │       ├── double_shared_buffer.py
│   │       └── triple_shared_buffer.py
│   └── perception/
│       ├── capture_process.py        # 启动Capture进程的逻辑
│       └── engines/                  # 具体的截图引擎实现
│           ├── base.py
│           └── mumu.py
├── calibration/                      # 校准文件的输出目录
├── configs/                          # 所有YAML配置文件
│   ├── settings.yaml
│   └── mumu.yaml
├── plans/                            # (规划中) Commander使用的自动化作战计划
├── tests/                            # 自动化测试套件
│   ├── conftest.py
│   ├── test_capture_workflow.py
│   └── test_mumu_engine.py
└── run.py                            # 应用的统一启动入口 (支持 run 和 calibrate 模式)
```

#### **4.2. 配置管理系统**

*   **格式**: 使用 `YAML` 格式，因其对复杂数据结构的出色可读性。
*   **校验**: 集成 `Pydantic` 库。为每个配置文件定义一个对应的Pydantic模型，在应用启动时自动加载、校验并合并所有配置。这确保了配置的类型安全和完整性，并能在启动早期就暴露配置错误。

#### **4.3. 开发与测试环境**

*   **启动入口 (`run.py`)**: 应用通过统一的 `run.py` 脚本启动，该脚本负责解析命令行参数，初始化IPC资源，并以正确的顺序启动所有子进程。
    *   **运行模式**:
        *   `run.py run`: **执行模式**。启动完整的 `Capture -> Ruler` 数据流管道。
        *   `run.py calibrate`: **校准模式**。启动一个专门的校准程序，为 `Ruler` 模块生成必要的帧数映射文件。
*   **帧数校准流程 (Calibration Process)**:
    *   **目的**: `Ruler` 进程依赖一个“像素宽度 -> 逻辑帧”的映射表来工作。此映射表必须针对用户的特定运行环境生成。
    *   **实现**: 当以`校准模式`启动时，`run.py` 会：
        1.  仅启动一个 `Capture` 引擎和一个专用的 `Calibrator` 逻辑。
        2.  `Calibrator` 会在一段时间内持续分析图像流，记录下费用条像素宽度的完整变化周期。
        3.  通过**聚类（Jaccard相似度）**和统计分析，`Calibrator` 能自动识别出一种或多种（例如30/60帧交替）费用条变化模型。
        4.  最终，它会生成一个包含所有模型的 `.json` 配置文件，并保存在 `calibration/` 目录下，供 `Ruler` 在**执行模式**下加载使用。
*   **优雅关闭**: `run.py` 会捕获中断信号（如 `Ctrl+C`），并负责向所有子进程发送关闭指令，确保共享内存等系统资源被正确清理和释放。