### **1. 概述 (Overview)**

本文档旨在阐述系统架构设计，这是一个为响应密集型实时应用（如游戏自动化）设计的高性能框架。框架的核心目标是在处理高速视频流时，实现从数据感知到指令控制的端到端超低延迟。

### **2. 核心需求与设计原则 (Core Requirements & Design Principles)**

系统设计遵循以下核心原则：

*   **实时性 (Real-time Performance)**: 框架必须能稳定处理 **144 FPS** 甚至更高帧率的视频流，并确保关键事件的响应延迟在毫秒级。
*   **数据新鲜度优先 (Data Freshness First)**: 在所有处理环节，系统永远优先处理**最新**的数据。过时的数据（例如，上一帧的图像或状态）将被主动丢弃，以确保所有决策都基于目标应用的当前瞬时状态。
*   **广播通信 (Broadcast Communication)**: 关键数据（如视频帧、状态信息）需以广播形式分发给多个独立的下游处理模块，允许并行分析和控制。
*   **精确事件触发 (Precise Event Triggering)**: 控制指令的执行必须与特定的数据状态（如视频流的某一帧）严格同步，杜绝时序漂移。
*   **模块化与领域驱动 (Modularity & Domain-Driven Design)**: 系统被划分为独立的、按功能领域组织的模块（感知、分析、控制），以实现高内聚、低耦合，增强代码的可维护性和可扩展性。
*   **配置与代码分离 (Configuration over Code)**: 系统的所有环境依赖和可变参数均通过外部配置文件管理，实现代码的通用性和环境的快速迁移。

### **3. 系统架构 (System Architecture)**

本框架采用基于**多进程**的微服务式架构。每个核心功能模块作为一个独立的操作系统进程运行，通过专门优化的**进程间通信（IPC）机制**进行协作。

#### **3.1. 进程角色定义 (Process Roles)**

系统由以下几类核心进程构成：

| 进程名称 | 所属领域 | 核心职责 | 输入数据 | 输出数据 |
| :--- | :--- | :--- | :--- | :--- |
| **`Capture`** | 感知 (Perception) | 从数据源（如模拟器）高速捕获视频帧。 | (无) | **图像流** |
| **`Ruler`** | 分析 (Analysis) | 分析图像流，提取核心的时间基准——**逻辑帧索引**。 | 图像流 | **帧索引流** |
| **`StateMonitor`** | 分析 (Analysis) | 通过视觉AI（如模板匹配）分析图像，识别应用的高级状态（如：成功、失败、等待中）。 | 图像流 | **状态流** |
| **`Commander`** | 控制 (Control) | 订阅**帧索引流**，加载并解释结构化的**作战计划**文件。在精确的逻辑帧，按预定顺序执行计划中的一系列核心操作。 | 帧索引流 | 控制指令 |
| **`LifecycleManager`** | 控制 (Control) | 订阅**状态流**，管理应用的宏观生命周期（如：失败后重试、成功后进入下一阶段）。 | 状态流 | 控制指令 |
| **`Recorder`** | 分析 (Analysis) | 订阅**帧索引流**，监听用户输入（如鼠标点击），自动录制操作并生成结构化的**作战计划**文件。 | 帧索引流, 用户输入 | 作战计划文件 |

#### **3.2. 进程间通信 (Inter-Process Communication)**

为实现极致性能，框架针对不同数据特性设计了专门的零拷贝或低开销IPC机制。

*   **图像流 (大数据量、高频率)**
    *   **技术选型**: **三缓冲共享内存 (Triple-Buffered Shared Memory)**
    *   **机制详解**:
        1.  **共享内存块**: 系统预先分配三块与单帧图像大小一致的 `SharedMemory` 区域，以及一小块额外的 `SharedMemory` 用于存储一个整数——即“最新帧”的索引。
        2.  **生产者**: `Capture` 进程作为生产者，循环地将最新捕获的图像写入其中一个缓冲区。写入操作无需加锁。
        3.  **消费者**: 所有消费者（如 `Ruler`）通过读取那块独立的共享内存，来原子地获取“最新帧”的索引值，然后直接从对应的图像缓冲区内存地址读取数据。
    *   **优势**:
        *   **零拷贝**: 数据在进程间传递无需任何内存复制。
        *   **无锁读取**: 读写操作完全解耦，消费者不会被生产者的写入操作阻塞，反之亦然。
        *   **保证数据新鲜度**: 消费者总能获取到最新的一帧完整图像。

*   **帧索引流 / 状态流 (小数据量、状态驱动)**
    *   **技术选型**: **基于共享内存的双缓冲 (Double-Buffered Shared Memory)**
    *   **机制详解**:
        1.  系统维护两个独立的共享内存槽，用于存储最新的状态数据结构（如`FrameData`），以及一个独立的共享内存用于存储指向“最新”槽的索引。
        2.  **生产者**（如`Ruler`）将新数据写入当前**未被使用**的槽中。写完后，原子性地更新共享索引，使其指向刚刚写完的新槽。
        3.  **消费者**（如`Commander`）在自己的循环中，主动地、无锁地读取共享索引，然后从索引指向的槽中拷贝数据。
    *   **优势**:
        *   **保证数据新鲜度**: 消费者若处理缓慢，会自动跳过中间状态，直接获取最新数据。
        *   **无锁读取**: 消费者永远不会读到正在被写入的“撕裂”数据。
        *   **完全解耦**: 生产者只负责发布状态，不关心是否有消费者，或消费者是否在监听。
        *   **高鲁棒性**: 消费者绝不会“错过”更新，只会看到最新的结果。

### **4. 关键实现细节 (Key Implementation Details)**

#### **4.1. 项目结构**

```
zhou_v2/
├── app/
│   ├── perception/
│   │   ├── capture_process.py
│   │   └── engines/
│   │       └── mumu.py
│   ├── analysis/
│   │   ├── ruler_process.py
│   │   └── calibrator.py
│   ├── control/
│   │   ├── commander_process.py    
│   │   ├── maatouch.py
│   │   └── ...
│   └── core/
│       ├── config.py
│       └── ipc/
│           ├── triple_shared_buffer.py
│           └── double_shared_buffer.py
│
├── calibration/                      # 校准文件的输出目录
│
├── configs/                          # 所有YAML配置文件
│
├── plans/                            # Commander使用的自动化作战计划
│   └── battle_plan_1.yaml
│
└── run.py                            # 应用的统一启动入口
```

#### **4.2. 配置管理系统**

*   **格式**: 使用 `YAML` 格式，因其对复杂数据结构的出色可读性。
*   **校验**: 集成 `Pydantic` 库。为每个配置文件定义一个对应的Pydantic模型，在应用启动时自动加载、校验并合并所有配置。

#### **4.3. Commander 与结构化作战计划 (Commander & Structured Battle Plans)**

`Commander` 进程是自动化逻辑的核心执行者，它严格按照结构化的作战计划行动。

*   **作战计划 (Battle Plan)**:
    *   **目的**: 定义了一系列需要在特定时间点（逻辑帧）执行的操作。它由手动编写或通过 `Recorder` 进程自动生成。
    *   **格式**: YAML 格式。其顶层是一个列表，每个元素代表一个“**触发组**”。
    *   **结构**: 采用**嵌套结构**来确保同帧内多个动作的执行顺序得以保留。
        *   `trigger_frame`: (整数) 触发执行的**总帧数**。
        *   `actions`: (列表) 在该帧需要**按顺序**执行的所有动作的列表。
            *   `action_type`: (字符串) 动作类型，如 `deploy`, `skill`, `recall`，需与控制器方法名对应。
            *   `params`: (字典) 执行该动作所需的参数。

    *   **示例 (`plans/battle_plan_1.yaml`)**:
        ```yaml
        - trigger_frame: 100
          actions:
            - action_type: deploy
              params:
                start_pos: [100, 1000]
                end_pos: [1090, 600]
                direction: 'left'
            - action_type: deploy  # <-- 同一帧内的第二个动作，顺序被保留
              params:
                start_pos: [280, 1000]
                end_pos: [1250, 600]
                direction: 'left'

        - trigger_frame: 650
          actions:
            - action_type: skill
              params:
                pos: [1090, 600]
        ```

*   **Commander 进程核心逻辑**:
    1.  **初始化**:
        *   连接到 `DoubleSharedBuffer` (帧索引流)。
        *   加载作战计划文件，并对顶层的“触发组”列表**按 `trigger_frame` 从小到大排序**。
        *   初始化一个 `next_action_index = 0` 的指针，指向下一个待执行的触发组。
    2.  **主循环**:
        *   高效轮询 `DoubleSharedBuffer` 获取最新的 `current_total_frames`。
        *   使用一个 `while` 循环检查 `current_total_frames` 是否**大于或等于** `plan[next_action_index]['trigger_frame']`。
            *   这种 `while` 和 `>=` 的组合确保了即使系统出现卡顿或跳帧，到期的任务也一定会被“追上”并执行，保证了鲁棒性。
        *   一旦触发条件满足：
            a. 获取该触发组的 `actions` 列表。
            b. **按顺序遍历** `actions` 列表，执行每一个动作（调用控制器相应方法）。
            c. 整个触发组执行完毕后，将 `next_action_index` 加 `1`。

#### **4.4. 帧数校准流程 (Calibration Process)**

*   **目的**: `Ruler` 进程依赖一个“像素宽度 -> 逻辑帧”的映射表来工作。此流程为用户的特定运行环境生成该映射表。
*   **实现**: 当以 `calibrate` 模式启动时，系统会运行一个专用校准程序，通过记录和分析费用条的完整变化周期，利用聚类算法自动识别变化模型，并生成 `.json` 配置文件供 `Ruler` 加载。