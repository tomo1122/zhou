### **1. 概述 (Overview)**

本文档旨在阐述系统架构设计，这是一个为响应密集型实时应用（如游戏自动化）设计的高性能框架。框架的核心目标是在处理高速视频流时，实现从数据感知到指令控制的端到端超低延迟。
这个项目是一个旧项目的重构说明，旧项目位于 zhou 下，可以参考原有的实现。

### **2. 核心需求与设计原则 (Core Requirements & Design Principles)**

系统设计遵循以下核心原则：

*   **实时性 (Real-time Performance)**: 框架必须能稳定处理 **144 FPS** 甚至更高帧率的视频流，并确保关键事件的响应延迟在毫秒级。
*   **数据新鲜度优先 (Data Freshness First)**: 在所有处理环节，系统永远优先处理**最新**的数据。过时的数据（例如，上一帧的图像或状态）将被主动丢弃，以确保所有决策都基于目标应用的当前瞬时状态。
*   **广播通信 (Broadcast Communication)**: 关键数据（如视频帧、状态信息）需以广播形式分发给多个独立的下游处理模块，允许并行分析和控制。
*   **精确事件触发 (Precise Event Triggering)**: 控制指令的执行必须与特定的数据状态（如视频流的某一帧）严格同步，杜绝时序漂移。
*   **模块化与领域驱动 (Modularity & Domain-Driven Design)**: 系统被划分为独立的、按功能领域组织的模块（感知、分析、控制），以实现高内聚、低耦合，增强代码的可维护性和可扩展性。
*   **配置与代码分离 (Configuration over Code)**: 系统的所有环境依赖和可变参数均通过外部配置文件管理，实现代码的通用性和环境的快速迁移。

### **3. 系统架构 (System Architecture)**

本框架采用基于**多进程**的微服务式架构。每个核心功能模块作为一个独立的操作系统进程运行，通过专门优化的**进程间通信（IPC）机制**进行协作。

#### **3.1. 进程角色定义 (Process Roles)**

系统由以下几类核心进程构成：

| 进程名称 | 所属领域 | 核心职责 | 输入数据 | 输出数据 |
| :--- | :--- | :--- | :--- | :--- |
| **`Capture`** | 感知 (Perception) | 从数据源（如模拟器）高速捕获视频帧。 | (无) | **图像流** |
| **`Ruler`** | 分析 (Analysis) | 分析图像流，提取核心的时间基准——**逻辑帧索引**。 | 图像流 | **帧索引流** |
| **`StateMonitor`** | 分析 (Analysis) | 通过视觉AI（如模板匹配）分析图像，识别应用的高级状态（如：成功、失败、等待中）。 | 图像流 | **状态流** |
| **`Commander`** | 控制 (Control) | 订阅**帧索引流**，根据预设脚本，在精确的逻辑帧执行核心操作。 | 帧索引流 | 控制指令 |
| **`LifecycleManager`** | 控制 (Control) | 订阅**状态流**，管理应用的宏观生命周期（如：失败后重试、成功后进入下一阶段）。 | 状态流 | 控制指令 |
| **`UI Renderer`** | 控制 (Control) | 订阅所有数据流，为用户提供一个实时的可视化监控界面。 | 所有数据流 | UI界面更新 |

#### **3.2. 进程间通信 (Inter-Process Communication)**

为实现极致性能，框架针对不同数据特性设计了专门的零拷贝或低开销IPC机制。

*   **图像流 (大数据量、高频率)**
    *   **技术选型**: **三缓冲共享内存 (Triple-Buffered Shared Memory)**
    *   **机制详解**:
        1.  **共享内存块**: 系统预先分配三块与单帧图像大小一致的 `SharedMemory` 区域，以及一小块额外的 `SharedMemory` 用于存储一个整数——即“最新帧”的索引。
        2.  **生产者**: `Capture` 进程作为生产者，循环地将最新捕获的图像写入其中一个缓冲区。写入操作无需加锁。
        3.  **消费者**: 所有消费者（如 `Ruler`）通过读取那块独立的共享内存，来原子地获取“最新帧”的索引值，然后直接从对应的图像缓冲区内存地址读取数据。
    *   **实现模式：创建者/附加者 (Creator/Attacher Pattern)**
        *   为了解决跨进程传递对象可能引发的数据视图陈旧问题，我们采用此模式。
        *   **创建者**：由主进程（`run.py`）首次实例化IPC对象（如 `TripleSharedBuffer`），负责实际创建共享内存块。
        *   **附加者**：所有子进程（如 `Capture`, `Ruler`）在启动后，都根据名称独立地实例化自己的IPC对象，并附加到由主进程已创建好的共享内存上。每个进程都创建自己对共享内存的Numpy视图，从而确保数据的一致性。
    *   **优势**:
        *   **零拷贝**: 数据在进程间传递无需任何内存复制。
        *   **无锁读取**: 读写操作完全解耦，消费者不会被生产者的写入操作阻塞，反之亦然。
        *   **保证数据新鲜度**: 消费者总能获取到最新的一帧完整图像。

*   **帧索引流 / 状态流 (小数据量、事件驱动)**
    *   **技术选型**: **基于条件变量的广播事件 (Condition Variable-based Broadcast)**
    *   **机制详解**:
        1.  一个共享的`Value`用于存储最新的状态值（如当前总帧数）。
        2.  一个`Condition`变量与该`Value`关联。
        3.  **生产者**（如`Ruler`）在更新共享`Value`后，立即调用`notify_all()`方法。
        4.  所有正在`wait()`的**消费者**（如`Commander`）会被操作系统内核高效唤醒，然后读取更新后的值。
    *   **优势**:
        *   **低延迟**: 事件通知接近内核级速度。
        *   **低CPU消耗**: 消费者在等待时处于睡眠状态，避免了无效的CPU轮询（忙等待）。
        *   **高效广播**: 一次通知即可唤醒所有订阅该事件的进程。

### **4. 关键实现细节 (Key Implementation Details)**

#### **4.1. 项目结构**

项目代码将被组织在一个主应用包内，并按功能领域划分子模块：

```
zhou_v2/
├── app/
│   ├── perception/
│   │   ├── __init__.py
│   │   ├── capture_process.py        # 启动Capture进程的逻辑
│   │   └── engines/                  # 具体的截图引擎实现
│   │       ├── __init__.py
│   │       └── mumu.py
│   ├── analysis/
│   │   ├── __init__.py
│   │   ├── ruler_process.py          # 启动Ruler进程的逻辑
│   │   ├── state_monitor_process.py  # 启动StateMonitor进程的逻辑
│   │   └── calibrator.py             # 校准算法的核心实现 (被run.py调用)
│   ├── control/
│   │   ├── __init__.py
│   │   ├── maatouch.py               # 使用maatouch进行安卓模拟器的控制
│   │   └── ...
│   └── core/
│       ├── __init__.py
│       ├── config.py                 # 配置加载与校验
│       └── ipc/                      # IPC模块封装
│           ├── __init__.py
│           ├── triple_shared_buffer.py
│           └── broadcast_event.py
│
├── assets/                           # 静态资源
│   └── templates/                    # StateMonitor使用的模板图片 (如"失败"截图)
│
├── calibration/                      # 校准文件的输出目录
│   └── (此目录初始为空, 校准后会生成 .json 文件)
│
├── configs/                          # 所有YAML配置文件
│   ├── settings.yaml
│   └── mumu.yaml
│
├── plans/                            # Commander使用的自动化作战计划
│   └── battle_plan_1.yaml
│
└── run.py                            # 应用的统一启动入口 (支持 run 和 calibrate 模式)
```

#### **4.2. 配置管理系统**

*   **格式**: 使用 `YAML` 格式，因其对复杂数据结构的出色可读性。
*   **校验**: 集成 `Pydantic` 库。为每个配置文件定义一个对应的Pydantic模型，在应用启动时自动加载、校验并合并所有配置。这确保了配置的类型安全和完整性，并能在启动早期就暴露配置错误。

#### **4.3. 开发与测试环境**

*   **启动入口 (`run.py`)**: 应用通过统一的 `run.py` 脚本启动，该脚本负责解析命令行参数，初始化IPC资源，并以正确的顺序启动所有子进程。
    *   **运行模式**:
        *   `run.py run`: **执行模式**。启动完整的自动化流程。
        *   `run.py calibrate`: **校准模式**。启动一个专门的校准程序，为 `Ruler` 模块生成必要的帧数映射文件。
*   **帧数校准流程 (Calibration Process)**:
    *   **目的**: `Ruler` 进程依赖一个“像素宽度 -> 逻辑帧”的映射表来工作。由于游戏在不同帧率（如30/60 FPS）下的费用条动画表现不同，此映射表必须针对用户的特定运行环境生成一次。
    *   **实现**: 当以`校准模式`启动时，`run.py` 会：
        1.  仅启动 `Capture` 进程和一个专用的 `Calibrator` 进程。
        2.  `Calibrator` 会在一段时间内持续分析 `Capture` 提供的图像流，记录下费用条像素宽度的完整变化周期。
        3.  通过聚类和统计分析，`Calibrator` 能自动识别出一种或多种（例如30/60帧交替）费用条变化模型。
        4.  最终，它会生成一个包含所有模型的 `.json` 配置文件，并保存在 `calibration/` 目录下，供 `Ruler` 在**执行模式**下加载使用。

*   **优雅关闭**: `run.py` 会捕获中断信号（如 `Ctrl+C`），并负责向所有子进程发送关闭指令，确保共享内存等系统资源被正确清理和释放。